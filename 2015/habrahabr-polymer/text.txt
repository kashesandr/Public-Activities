Вебкомпоненты -> Polymer 1.0 -> Пример

# Введение

Хочется поделиться с сообществом своими знаниями и опытом. Думаю, будет полезно.

## Кто я
Я - Александр Кашеверов, веб-разработчик, работаю в компании DataArt с 2011 года.

## О чём статья
Статья про веб-комоненты и Polymer.

## Вступление
Веб постоянно развивается. Технологии для веба были придуманы и внедрены исходя из потребностей, актуальных на момент создания. Десять лет назад невозможно было сделать то, что мы реализуем сейчас, сложно представить что будет еще через 19 лет..
Бизнес сейчас требует создания крупных программных веб-продуктов с широкой функциональностью, красотой, высокой производительностью. И бизнес готов вкладывать в это деньги. Однако, сложные и крупные решения в WEB делать непросто из-за специфичности технологий. Чтобы уменьшить сложность продукта, его разделяют на множество более простых частей. Подобный компонентный подход позволяет вести разработку отдельных частей продукта независимо от других частей, а так же позволяет повторно использовать уже готовые. Разработка одних компонентов должна быть максимально независима от разработки других компонентов. Для нас в контексте веба при подобном подходе необходимо чтобы:
 1. CSS не пересекался.
 2. Области видимости JS не пересекались.
 3. HTML был понятным и читаемым. Никаких излишних элементов.
Увы, на момент сейчас это не так. JavaScript - приходится следить, чтобы он не работал в global scope и разные компоненты случайно не стали взаимодействовать друг с другом. CSS - вообще странная вещь, у него нет и не было инкапсуляции... Приходится придумывать методологии вроде https://operatino.github.io/MCSS и https://bem.info, чтобы в крупном проекте ничего лишний раз не сломалось. HTML - можно увидеть множество излишних элементов на странице, например даже сейчас в почте gmail: <img src="assets/a-lot-of-divs.png">.
Фреймворки в той или иной степени внедряют компонентизацию и пытаются решить задачи. Angular, к примеру, даёт возможность создавать директивы с изолированной логикой и их достаточно просто переиспользовать. Даже CSS в Angular можно псевдоинкапсулировать (https://github.com/Yappli/angular-css-injector).

# Web Components - коротко

WEB медленно, но верно, движется к компонентизации - это естесственный процесс. Всё сложное можно упростить, разбив на более простые части. Набирают популярность веб компоненты. Написано уже много статей на (http://habrahabr.ru/post/210058/) эту (http://habrahabr.ru/post/210130/) тему (http://habrahabr.ru/company/microsoft/blog/264791/). Это реализация идеи компонентизации на уровне браузера.
Веб компоненты начали свою историю в 2011 году (первое упоминание на github https://github.com/w3c/webcomponents/commit/4a2e2daa58222b97e3cb7791f10022b7d9dedd4d). Кратко рассмотрим что это.
Они состоят и 4 основных частей:
- Custom Elements (создание своих html элементов, дополнение существующих)
- Shadow DOM (инкапсуляция логики и стилей)
- Templates (создание шаблонов)
- HTML imports (вместо отдельного подключения разных типов файлов [css, js, ..] - можно подключать один HTML документ, включающий все остальные файлы)
Соединяя эти 4 технологии вместе получаются автономные пеереиспользуемые блоки - веб компоненты.

На самом деле, некое подобие вебкомпонент уже было создано давно. Простейший пример - элемент <select>. Для него есть отдельный тег. Взаимодействуя с элементом, появляется выпадающий список и эта логика скрыта от нас, к тому же у него есть свои собственные стили. Так же с HTML5 элементами <video> или <audio>. В этом и есть суть вебкомпонентов - создание простых и понятных независимых элементов со скрытой логикой, стилями.

Наверняка, многие подключали в проект Bootstrap - для этого нужно отдельно прописать подгрузку стилей и скриптов. С компонентами это можно будет сделать проще:
[code]<link rel="import" href="bootstrap.html"></link>[/code]

Web components - не фреймворк. Это набор технологий, реализованных на уровне браузера.

## Web Components - поддержка браузерами и полифилы
На данный момент 3 из 4 технологий находятся в стадии "Working Draft" на W3C (http://www.w3.org/standards/techs/components#w3c_all).
И, конечно, технологии не поддерживаются всеми браузерами.
Текущее состояние дел:
- http://caniuse.com/#search=components
- http://jonrimmer.github.io/are-we-componentized-yet/
Так как веб компоненты в перспективе имеют высоую ценность, но еще не поддерживаются всеми браузерами, то создаются способы, чтобы технология-таки работала везде. Так появились полифиллы https://github.com/webcomponents/webcomponentsjs#browser-support. Используя их, поддержка бреузерами уже получше. Подключается как обычно в head <script src="path/webcomponents.min.js"></script>

## web components - ссылки
http://webcomponents.org/ - (eng) обсуждения и лучшие практики
https://learn.javascript.ru/webcomponents - обучение
https://developer.mozilla.org/en-US/docs/Web/Web_Components - (eng) обучение
https://css-tricks.com/modular-future-web-components/ (eng) - обзор
http://caniuse.com/#search=components - (eng) поддержка браузерами
http://jonrimmer.github.io/are-we-componentized-yet/ - (eng) поддержка браузерами
https://github.com/webcomponents/webcomponentsjs#browser-support - (eng) поддержка браузерами

# Polymer

Тем временем Google всё упрощает и развивает. Работа началась осенью 2012 года, судя по истории коммитов на github (https://github.com/Polymer/polymer/commit/0452ada044a6fc5818902e685fb07bb4678b2bc2). Они взяли веб компоненты, полифилы и создали еще одну надстройку над всем этим.
Цель Polymer - упростить создание качественных веб-приложений (со слов product manager'а с конференции Google IO).

## Polymer - коротко
Полимер из себя представляет те же вебкомпоненты в основе (Shadow Dom, Custom Elements, Html Imports, Templates), полифилы для поддержки старых браузеров, всё это обёрнуто в целостную более удобную экосистему с добавлением сахара.
А на основе этого Google создал набор переиспользуемых компонентов. Разбили их на логические части <image src="assets/polymer.png">
 - Iron Elements - Основные строительные блоки (<iron-icon>, <iron-input>, <iron-list>, ...)
 - Paper Elements - Готовые переиспользуемые элементы на основе iron-elements и material design (<paper-input>, <paper-button>, <paper-tooltip>, ... )
 - Google Web Components - Коллекция веб компонентов, использующих различные API Google (<google-analytics>, <google-chart>, <google-map>, ...)
 - Gold Elements - Элементы, специфичные для интернет-коммерции. (<gold-cc-input>, <gold-phone-input>, <gold-email-input>, ...)
 - Neon Elements - Элементы для создания анимаций (<neon-animation>)
 - Platinum Elements - Элементы, помогающие создать из веб-страницы настоящее веб приложение (<platinum-bluetooth-device>, <platinum-sw-cache>, <platinum-push-messaging>, ...)
 - Molecules - Элементы-обёртки других библиотек/приложений (<marked-element>)
Как Вы могли заметить, постоянно фигурирует слово "элемент". Google считает, что для всего есть элементы. "There is an element for that" - звучит как слоган в докладах Google IO 2015 (доклад https://www.youtube.com/watch?t=5&v=fD2As5RmM8Q (english) кстати интересно, советую посмотреть).
Да, даже для ajax запроса есть элемент.
Выглядит так:
<iron-ajax
  id="ajax"
  url="<some url>"
  handle-as="json"
  on-response="hresponse"
  debounce-duration="300">
</iron-ajax>

При создании приложений мы сталкиваемся постоянно с примерно одинаковыми задачами и Google предлагает набор готовых строительных блоков для этого. С какой проблемой бы мы не столкнулись - для её решения есть элемент. "There is an element for that".
Есть каталог готовых Polymer-компонент http://elements.polymer.com.

Polymer - это не фреймворк, так же как Web Components - не фреймворк. Polymer - это обёртка и сахар. Я бы идейно ее сравнил с jQuery. Но jQuery создана для работы с DOM, а Polymer для работы с Web Components.

Далее, рассмотрим пример вебкомпонента и его Polymer-реализацию:

Пример чистого веб-компонента:

<template>
    <span id="multiplier"></span> * <span id="multiplicand"></span> = <span id="result"></span>
</template>

<script>

    (function(window, document) {
        var ownerDocument =  (document._currentScript || document.currentScript).ownerDocument;
        var template = ownerDocument.querySelector('template').content;
        var elementPrototype = Object.create(HTMLElement.prototype);

        var multiplier = 0, multiplicand = 0, result = 0;

        elementPrototype.createdCallback = function() {
            var shadowRoot = this.createShadowRoot();
            var clone = document.importNode(template, true);
            shadowRoot.appendChild(clone);

            this.multiplier = shadowRoot.querySelector('#multiplier');
            this.multiplicand = shadowRoot.querySelector('#multiplicand');
            this.result = shadowRoot.querySelector('#result');

            this.calculate();
        };

        elementPrototype.attributeChangedCallback = function(attr, oldVal, newVal) {
            this.calculate();
        };

        elementPrototype.calculate = function(){
            multiplier = parseFloat( this.getAttribute('multiplier') );
            multiplicand = parseFloat( this.getAttribute('multiplicand') );
            this.multiplier.textContent = multiplier;
            this.multiplicand.textContent = multiplicand;
            this.result.textContent = multiplicand*multiplier;
        };
        window.MyElement = document.registerElement('element-multiplier', {prototype: elementPrototype });
    })(window, document);

</script>

Подключаем в <head> -> <link rel="import" href="element-multiplier.html">
Используем на странице (в <body>) -> <element-multiplier multiplier="3" multiplicand="2"></element-multiplier>

С Polymer будет выглядеть значительно понятней и проще:

<link rel="import" href="polymer.html">

<dom-module id="element-multiplier">
    <template>
        <span>{{multiplier}}</span> * <span>{{multiplicand}}</span> = <span>{{result}}</span>
    </template>
</dom-module>

<script>
    Polymer({
        is: "element-multiplier",
        properties: {
            "multiplier"    : { type: Number, value: 0, observer: 'calculate' },
            "multiplicand"  : { type: Number, value: 0, observer: 'calculate' },
            "result"        : { type: Number, value: 0 }
        },
        ready: this.calculate,
        calculate: function(){
            this.result = this.multiplier*this.multiplicand;
        }
    });
</script>

Подключаем в <head> -> <link rel="import" href="element-multiplier.html">
Используем на странице (в <body>) -> <element-multiplier multiplier="3" multiplicand="2"></element-multiplier>

## Polymer - тестируемость
Да, он тестируемый и для этого создана отдельная утилита (https://github.com/Polymer/web-component-tester). Достаточно понятное описание. Пробовал настроить - работает.

## Polymer - поддержка браузерами
У меня так и не получилось запустить на старом андроид-телефоне
https://www.polymer-project.org/1.0/resources/compatibility.html
<вставить табличку отсюда https://www.polymer-project.org/1.0/resources/compatibility.html>

## Polymer - оптимизация vulcanize
HTML imports позволяет быстро и удобно подключить документ в другой документ, но в этом удобстве скрывается и проблема производительности - создается большое множество http-запросов. Решение есть - соединиить все подключаемые файлы в один. Для этого нужна утилита vulcanize (https://github.com/polymer/vulcanize).
Установка: `npm install -g vulcanize`
Использование: `vulcanize index.html > build.html`

## Polymer - starter kit
Для удобства создана утилита (https://github.com/PolymerElements/polymer-starter-kit). После установки доступно множество полезной функциональности.

## Polymer - альтернативы
Polymer - это лишь надстройка над Web Components. Есть и другие подобные продукты:
http://bosonic.github.io/
http://x-tags.org/ (с поддержкой IE9)

## Polymer - ссылки
https://www.youtube.com/watch?v=fD2As5RmM8Q - (eng) Google IO 2015
https://aerotwist.com/blog/polymer-for-the-performance-obsessed/ - (eng) немного про оптимизацию и производительность

## Polymer - немного про взаимодействие с библиотеками
Вебкомпоненты будут внедрены в Angular 2: http://angularjs.blogspot.ru/2015/03/announcements-from-ng-conf-were.html (eng)

Официальный представитель от React Sebastian Markbage (https://twitter.com/sebmarkbage) говорит, что они не будут использовать Web Components совместно с React, т.к. они идеологически разные (декларативный React против императивных Web Components): https://docs.google.com/document/d/1QZxArgMwidgCrAbuSikcB2iBxkffH6w0YB0C1qCsuH0/edit (eng)
Однако, React и Web Components совместимы, в некоторых случаях есть преимущества: https://www.youtube.com/watch?v=g0TD0efcwVg (eng)

Backbone & Web Components
Удобно скрестить с уже готовыми компонентами (Polymer, X-Tags, Bosonic). Используются точно так же как и обычные html-элементы. http://webcomponents.org/presentations/webcomponents-plus-backbone-a-game-changing-combination-at-backbone-conf/ (eng)

## Polymer - примеры
http://www.pubnub.com/blog/creating-a-polymer-chat-app-with-material-design/ - (eng)
https://translate.google.com/
https://play.google.com/music/listen#/sulp
http://todomvc.com/examples/polymer/index.html
https://santatracker.google.com/
http://pubnub.github.io/paper-chat/ - anonymous chat
https://home-assistant.io/demo/ - home assist

http://github.com/kashesandr/CIC - моё маленькое приложение. Идея проста: когда группа людей делают совместную покупку с одинаковыми вкладами, то часто возникает путаница в расчётах долгов, когда скидываются не все сразу. Писал было специально для того, чтобы попробовать Polymer. Там есть рабочий пример тестов и vulcanize.

# Если есть ошибки или дополнения - пишите личным сообщением. Спасибо!
